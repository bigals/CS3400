<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>CS3400 JavaScript Website: Unit Testing</title>
        
        <!--Custom Style Sheets-->
        <link rel="stylesheet" href="Styles/styles.css" />
        <link rel="stylesheet" href="Styles/navBar.css" />
        
        <!--JQuery Library-->
        <script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
        
        <!--JQuery UI Library-->
        <link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.1/themes/smoothness/jquery-ui.css" />
        <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.11.1/jquery-ui.min.js"></script>
        
        <!--Custom Scripts-->
        <script src="Scripts/scripts.js"></script>
    </head>
    <body>
        <div id="pageWrapper">
            <header>
                <h1>JavaScript Unit Testing</h1>
                <nav id="navBar">
                    <label for="show-menu" class="show-menu">Show Menu</label>
                    <input type="checkbox" id="show-menu" role="button">
                    <ul id="menu">
                        <!--Home Menu -->
                        <li>
                            <a href="index.html?tOpVal=1">Home</a>
                            <ul class="hidden">
                                <li><a href="index.html?tOpVal=1">Welcome</a></li>
                                <li><a href="index.html?tOpVal=2">Security Issues</a></li>
                                <li><a href="index.html?tOpVal=3">Standards/Browsers</a></li>
                                <li><a href="index.html?tOpVal=4">Embedded Browsers</a></li>
                            </ul>
                        </li>
                        
                        <!--JavaScript Best Practices Menu -->
                        <li>
                            <a href="bestPractices.html?tOpVal=1">Best Practices</a>
                            <ul class="hidden">
                                <li><a href="bestPractices.html?tOpVal=1">Paradigms to Use</a></li>
                                <li><a href="bestPractices.html?tOpVal=2">Paradigms to Avoid</a></li>
                                <li><a href="bestPractices.html?tOpVal=3">Superior Paradigms</a></li>
                                <li><a href="bestPractices.html?tOpVal=4">Naming Conventions</a></li>
                                <li><a href="bestPractices.html?tOpVal=5">Format Conventions</a></li>
                            </ul>
                        </li>
                        
                         <!--JavScript Unit Testing Menu -->
                        <li>
                            <a href="jsTesting.html?tOpVal=1">Unit Testing</a>
                            <ul class="hidden">
                                <li><a href="jsTesting.html?tOpVal=1">What is Unit Testing</a></li>
                                <li><a href="jsTesting.html?tOpVal=2">The QUnit Solution</a></li>
                                <li><a href="jsTesting.html?tOpVal=3">Asserting Results</a></li>
                                <li><a href="jsTesting.html?tOpVal=4">Synchronous Callbacks</a></li>
                                <li><a href="jsTesting.html?tOpVal=5">Asynchronous Callbacks</a></li>
								<li><a href="jsTesting.html?tOpVal=6">Testing User Actions</a></li>
                                <li><a href="jsTesting.html?tOpVal=7">Keeping Tests Atomic</a></li>
                                <li><a href="jsTesting.html?tOpVal=8">Grouping Tests</a></li>
                                <li><a href="jsTesting.html?tOpVal=9">Custom Assertions</a></li>
                                <li><a href="jsTesting.html?tOpVal=10">Efficient Development</a></li>
                            </ul>
                        </li>
                        <!--JavaScript Debugging Menu -->
                        <li>
                            <a href="jsDebugging.html?tOpVal=1">Debugging & IDEs</a>
                            <ul class="hidden">
                                <li><a href="jsDebugging.html?tOpVal=1">Debugging Tools</a></li>
                                <li><a href="jsDebugging.html?tOpVal=2">JavaScript IDEs</a></li>
                            </ul>
                        </li>
                        <!--JavaScript Tutorials/Examples Menu -->
                        <li>
                            <a href="examples.html?tOpVal=1">JS Tutorials/Examples</a>
                            <ul class="hidden">
                                <li><a href="examples.html?tOpVal=1">Various JS Examples</a></li>
                                <li><a href="examples.html?tOpVal=2">Local File Access</a></li>
                                <li><a href="examples.html?tOpVal=3">Basic Canvas</a></li>
                                <li><a href="examples.html?tOpVal=4">KineticJS Canvas</a></li>
                                <li><a href="examples.html?tOpVal=5">Drag & Drop</a></li>
                                <li><a href="examples.html?tOpVal=6">WebGL</a></li>
                            </ul>
                        </li>
                        <!--JQuery Tutorials/Examples Menu -->
                        <li>
                            <a href="jqueryBestPract.html?tOpVal=1">JQuery</a>
                            <ul class="hidden">
                                <li><a href="jqueryBestPract.html?tOpVal=1">Intro to JQuery</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=2">Selectors</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=3">DOM Manipulation</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=4">Events</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=5">Ajax</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=6">Effects and Animations</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=7">Plugins</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=8">Chaining</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=9">Miscellaneous</a></li>
                                <li><a href="jqueryBestPract.html?tOpVal=10">JQuery Mobile</a></li>
                            </ul>
                        </li>
                        <!--JavaScript Assignment Menu -->
                        <li>
                            <a href="assignment.html?tOpVal=1">Simple Assignment</a>
                        </li>
                    </ul>									
                </nav>
            </header>
            <div id="content">
			<div id="contentNavBar">
                    <div id="cNav-1" class="contentBtn">What is Unit Testing?</div>
                    <div id="cNav-2" class="contentBtn">The QUnit Solution</div>     
					<div id="cNav-3" class="contentBtn">QUnit-Asserting Results</div> 
					<div id="cNav-4" class="contentBtn">QUnit-Synchronous Callbacks</div> 
					<div id="cNav-5" class="contentBtn">QUnit-Async Callbacks</div> 
					<div id="cNav-6" class="contentBtn">QUnit-Testing User Actions</div> 
					<div id="cNav-7" class="contentBtn">QUnit-Keeping Tests Atomic</div> 
					<div id="cNav-8" class="contentBtn">QUnit-Grouping Tests</div> 
					<div id="cNav-9" class="contentBtn">QUnit-Custom Assertions</div> 
					<div id="cNav-10" class="contentBtn">QUnit-Efficient Development</div> 

                </div>

			<div id="contentFrame">
			<div id="content-1" class="contentPanels">
			<img  src="Images/Unit-testing.png" style= "display: block;
    margin: 0 auto;" /><br/>
			<center> This comic id from: <a href="http://www.leonardscomic.com/comic/68/unit-testing/"> LeonardsComics.com </a></center>
			<h2>What is Unit Testing?</h2>
			<p> Unit testing is the automated testing of software that can be run
				over and over with any need for any additional interactions. So 
				this means you can write a test once and you it as often as you need
				it with out adding any additionals costs. 
			</p>
			<h2> A Essential Tool</h2>
			<p>	This is an <strong><em>essential tool</em></strong> for development. 
				Not only does this help with testing, but it can help you to design
				your software. This is a process known as <em> test-driven design</em> 
				where you start writting your unit test be you even starting writting 
				the code you will to implement. You would start by writting a very 
				simple test, check that it fails and then change it until the 
				implmentation unit it passes. Then from there you follow the same steps 
				until you include all your wanted functionality. 
			<p>
			<h2>What You Will Need: </h2>
			<p> <li>Small framework to provide a test runner.</li>
				<li>A few  utilities to write the tests</li>
			</p>
			</div>
			<div id="content-2" class="contentPanels">
			<h1>A Summary of QUnit</h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/" target="blank">qunitjs.com</a> ~</h2>
			<h2>The QUnit Solution </h2>
			<p> Creating your own framework to test JavaScript would take alot of work
				to include all the details and needed requirements for the many different
				browsers that are used to day. 
			</p>
			<p>The good news is that are many different testing frameworks. One commonly
				used one is QUnit. Qunit is JQuery's unit test framework and is currently 
				used on many different projects.
			</p>
			<h2> Using QUnit</h2>
			<p>If you want to use QUnit to need to include two files on your page.
				<li><a href="https://code.jquery.com/qunit/qunit-1.15.0.js" target="blank">qunit.js:</a> The test runner and framework. </li>
				<li><a href="https://code.jquery.com/qunit/qunit-1.15.0.css" target="blank">qunit.css:</a> The test suite's display page style's. </li>
			</p>
			<textarea class="codeBlock">
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>QUnit basic example</title>
  <link rel="stylesheet" href="https://code.jquery.com/qunit/qunit-1.15.0.css">
</head>
<body>
  <div id="qunit"></div>
  <div id="qunit-fixture"></div>
  <script src="https://code.jquery.com/qunit/qunit-1.15.0.js"></script>
  <script>
	QUnit.test( "a basic test example", function( assert ) {
	  var value = "hello";
	  assert.equal( value, "hello", "We expect value to be hello" );
	});
  </script>
</body>
</html>
			</textarea>
			<center>Test Results</center>
			<iframe src="QUnitTest1.html"  width="800" height="200" frameborder="0" ></iframe>
			<p> The only thing you will need in the &lt;body&gt; tag is a &lt;div&gt; 
			with the id <strong>id="qunit-fixture"</strong>. This will be required 
			for all QUnit tests even if it's empty. This provides the fixtures 
			for texts which will be explained under "Keeping Tests Atomic".
			</p>
			<p> This &lt;script&gt; tag following the qunit.js include is the
			call for the test function. The test function has two arguments:
			<li> A string used for the test name, to be used later to display 
			the test results.</li>
			<li>A function, which has the actula testing code. Involving more 
			or more assertions. This example here uses <strong>equal()</strong>. 
			This will be explained in "Asserting Results". 
			</p>
			<p>
			It's important to note that there is no document-ready block. This is 
			handled by the test runner when qUnit.test() is called. It will be 
			added to the queue and its execution is deferred and contolled by the
			test runner.
			</p>
			<p> In order to understand how to read the test results page we will
				cover its components. The header will display:
				<li>The page tile </li>
				<li>A green bar when all tests have passed.</li>
				<li>A red bar when at least one test has failed.</li>
				<li>A bar with a view checkboxes to filter test results.</li>
				<li>A blue bar with the <strong>navigator.userAgent</strong> string.
				(Usefull for screenshots of test results in different browsers.)
			</p>
			<h2>Checkboxes</h2>
			<p>Using the checkboxes can be very useful. For examples clicking "hide passed tests 
				when a lot of tests passed and only a few failed. This will hide all the tests 
				that passed. This will help you to focus on just the test that failed.
			</p>
			
			<p> Using the "Check for Globals" checkbox makes Qunit create a list of all the window 
			objects properties before and after each test. Then it will check them for differences.
			This is very helpfull to make sure your code doesn't accidentally export global properties.
			</p>
			<p> The last checkbox "No try-catch" tell QUnit to test your code outside of a try-catch
				block. If your test throws a exception, the test runner will die. Due to being unable 
				to continue running you will get a "native" exception. This can be very helpful when
				debugging older browser with poor debugging support. 
			</p>
			
			<p>Under the header is a summary that shows the total time it took to 
				run all the tests along with the overal number of total and failed assertions. 
				If you still have a test running it will also show what test is being ran.
			</p>
			
			<p> The contents of the test results page are the actual results. Every entry
			in the numbered list will start with the name of the test. Then it will be followed 
			by the number of failed, passed, and total assertions each being encosed in partentheses.
			Clicking on a entry will show the results of each assertion. This will include details
			about expected verus actual results. You can also use the "Rerun" link to run the test again 
			on its own.
			</p>
		
			
			</div>
			<div id="content-3" class="contentPanels">
			<h1>QUnit-Asserting Results</h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/" target="blank">qunitjs.com</a> ~</h2>
			<h2>Problem</h2>
			<p> A essential element of a unit test are assertions. The writer of a test
			needs to express the expected results and then have the testing framework 
			compare them to the actual values that are produced.
			
			<h2>Solutions</h2>
			<p> QUnit has many different built in assertions. View full 
			<a href="http://api.qunitjs.com/category/assert/" target="blank">list</a>.
			The three most common are:
			<li>ok( truthy [, message ]</li>
			<li>equal( actual, expected [, message ] )</li>
			<li>deepEqual( actual, expected [, message ] )</li>
			</p>
			
			<h3>ok( truthy [, message ]</h3>
			<p>This the the most basic assertions and requries only one argument.
			If the argument is true, it passes, otherwise it will fail. This will also accept
			a string to display as a message in the results.<br/><br/>
			
			<textarea class="codeBlock">
QUnit.test( "ok test", function( assert ) {
  assert.ok( true, "true succeeds" );
  assert.ok( "non-empty", "non-empty string succeeds" );
 
  assert.ok( false, "false fails" );
  assert.ok( 0, "0 fails" );
  assert.ok( NaN, "NaN fails" );
  assert.ok( "", "empty string fails" );
  assert.ok( null, "null fails" );
  assert.ok( undefined, "undefined fails" );
});
			</textarea>
			<h3>equal( actual, expected [, message ] )</h3>
			<p>This assertion will use the simple  comparison operator (= =) 
			to compare the actual and expected arguments. When they are equal it passes,
			otherwise the test fails. When it does fail both actual and expected will be 
			given in the results. You can also pass a string message. 
			</p>
			<p>This function is easier to use for debugging failed test, becasue it will be
			obivious what casued it to fail.
			</p>
			<p><strong>Tip: </strong> If you need to a strict comparison (===), use strictEqual() instead.
			<br/><br/>
			<textarea class="codeBlock">
QUnit.test( "equal test", function( assert ) {
  assert.equal( 0, 0, "Zero, Zero; equal succeeds" );
  assert.equal( "", 0, "Empty, Zero; equal succeeds" );
  assert.equal( "", "", "Empty, Empty; equal succeeds" );
  assert.equal( 0, false, "Zero, false; equal succeeds" );
 
  assert.equal( "three", 3, "Three, 3; equal fails" );
  assert.equal( null, false, "null, false; equal fails" );
});

			</textarea>
			</p>
			<h3>deepEqual( actual, expected [, message ] )</h3>
			<p> This assertion can be used like the <strong>equal()</strong>, but this is 
			better for one main reason. It used a more accurate comparison operator (===) 
			instead of (==). This means a undefined doesn't equal null, 0 or a empty string ("").
			It will also compare the content of objects. Example: {key:value} is {key:value}, even if 
			comparing two objects that have distinct identities. 
			</p>
			<p><strong>Tip: </strong>deepEqual() also handles NaN, dates, regular expressions, arrays, and
			functions, while equal() would just check the object identity.
			<br/><br/>
			<textarea class="codeBlock">
QUnit.test( "deepEqual test", function( assert ) {
  var obj = { foo: "bar" };
 
  assert.deepEqual( obj, { foo: "bar" }, "Two objects can be the same in value" );
});
			</textarea>
			
			</div>
			<div id="content-4" class="contentPanels">
			<h1>QUnit-Synchronous Callbacks</h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/" target="blank">qunitjs.com</a> ~</h2>
			<h2>Problem</h2>
			<p>Sometimes certain things in your code may prevent callback assertions to
			never be called. Thus making your test fail silently.
			</p>
			<h2>Solution</h2>
			<p>To fix this QUnit has a special assertion that deines the number of assertions
			a test will contain. If a test was to complete with the correct number of assertions, 
			it will fail, no matter what the results of the other assertions are. 
			</p>
			<p>This will provide the most value when testing callbacks.
			When all code is running in the scope of the test function,  expect() provides
			no additional valueâ€”any error preventing assertions to run would cause the test 
			to fail anyway, because the test runner catches the error and fails the unit.			
			</p>
			<p> To using this all you have to do it call <strong>expect()</strong> at the start of your 
			test. Passing in the number of expected assertions.
			<br/><br/>
			<textarea class="codeBlock">
QUnit.test( "a test", function( assert ) {
  expect( 2 );
 
  function calc( x, operation ) {
    return operation( x );
  }
 
  var result = calc( 2, function( x ) {
    assert.ok( true, "calc() calls operation function" );
    return x * x;
  });
 
  assert.equal( result, 4, "2 square equals 4" );
});
			</textarea>
			<br/><br/>
			Example:<br/>
			<textarea class="codeBlock">
QUnit.test( "a test", function( assert ) {
  expect( 1 );
 
  var $body = $( "body" );
 
  $body.on( "click", function() {
    assert.ok( true, "body was clicked!" );
  });
 
  $body.trigger( "click" );
});
			</textarea>
			</div>
			<div id="content-5" class="contentPanels">
			<h1>QUnit-Asynchronous Callbacks</h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/" target="blank">qunitjs.com</a> ~</h2>
			<h2>Problem</h2>
			<p>The function expect() is useful to test synchronous callback. However it fails on
				Asynchronous callbacks. The conflict is caused by the way the test runner 
				queues and executes tests. When code under test starts a timeout or interval or an Ajax 
				request, the test runner will just continue running the rest of the test, as well as other 
				tests following it, instead of waiting for the result of the asynchronous operation.		
			</p>
			<h2>Solution</h2>
			<p>To fix this you need to use <strong>QUnit.asyncTest()</strong> and call <strong>QUnit.start()</strong>
			when your test block is complete and ready to resume. <br/><br/>
			<textarea class="codeBlock">
QUnit.asyncTest( "asynchronous test: one second later!", function( assert ) {
  expect( 1 );
 
  setTimeout(function() {
    assert.ok( true, "Passed and ready to resume!" );
    QUnit.start();
  }, 1000);
});
			
			</textarea>
			
			</p>
			<p>Example:<br/>
			<textarea class="codeBlock">
QUnit.asyncTest( "asynchronous test: video ready to play", function( assert ) {
  expect( 1 );
 
  var $video = $( "video" );
 
  $video.on( "canplaythrough", function() {
    assert.ok( true, "video has loaded and is ready to play" );
    QUnit.start();
  });
});
			</textarea>
			</p>
			
			</div>
			<div id="content-6" class="contentPanels">
			<h1>QUnit-Testing User Actions</h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/" target="blank">qunitjs.com</a> ~</h2>
			<h2>Problem</h2>
			<p> Sometimes you have code that has actions initiated by the user. This code
			can not be tested by just calling a function. Usually an anonymous function is bound 
			to an element's event, e.g., a click, which has to be simulated.  
			</p>
			<h2>Solution</h2>
			<p> You can use jQuery's <strong>trigger()</strong> method to test for the expected 
			behavior. If you don't want the native browser events to be triggered, you can use 
			triggerHandler() to just execute the bound event handlers. This is useful when 
			testing a click event on a link, where trigger() would cause the browser to 
			change the location, which is hardly desired behavior in a test.
			<br/><br/>
			We have a simple key logger test:
			<textarea class="codeBlock">
function KeyLogger( target ) {
  if ( !(this instanceof KeyLogger) ) {
    return new KeyLogger( target );
  }
  this.target = target;
  this.log = [];
 
  var self = this;
 
  this.target.off( "keydown" ).on( "keydown", function( event ) {
    self.log.push( event.keyCode );
  });
}
			</textarea><br/><br/>
			Manually trigger a keypress event to see whether the logger is working: <br/>
			<textarea class="codeBlock">
QUnit.test( "keylogger api behavior", function( assert ) {
 
  var event,
      $doc = $( document ),
      keys = KeyLogger( $doc );
 
  // trigger event
  event = $.Event( "keydown" );
  event.keyCode = 9;
  $doc.trigger( event );
 
  // verify expected behavior
  assert.equal( keys.log.length, 1, "a key was logged" );
  assert.equal( keys.log[ 0 ], 9, "correct key was logged" );
 
});
			
			</textarea>
			
			</p>
			<p>"If your event handler doesn't rely on any specific properties of 
			the event, you can just call<strong> .trigger(eventType)</strong>. 
			However, if your event handler does rely on specific properties of the
			event, you will need to create an event object using <strong> $.Event</strong> 
			and set the necessary properties, as shown previously.
			It's also important to trigger all relevant events for complex behaviors 
			such as dragging, which is comprised of mousedown, at least one mousemove,
			and a mouseup. Keep in mind that even some events that seem simple are 
			actually compound; e.g., a click is really a mousedown, mouseup, and 
			then click. Whether you actually need to trigger all three of these 
			depends on the code under test. Triggering a click works for most cases.
			If thats not enough, you have a few framework options that help simulating user events":

<li>syn "is a synthetic event library that pretty much handles typing, clicking, moving, and dragging exactly how a real user would perform those actions". Used by FuncUnit, which is based on QUnit, for functional testing of web applications.</li>

<br/>
<li>JSRobot - "A testing utility for web-apps that can generate real keystrokes rather than simply simulating the JavaScript event firing. This allows the keystroke to trigger the built-in browser behaviour which isn't otherwise possible."</li>
<br/>
<li>DOH Robot "provides an API that enables testers to automate their UI tests using real, cross-platform, system-level input events". This gets you the closest to "real" browser events, but uses Java applets for that.</li>
<br/>
<li>keyvent.js - "Keyboard events simulator."</li>
			
			</p>
			</div>
			<div id="content-7" class="contentPanels">
			<h1>QUnit-Keeping Tests Atomic </h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/" target="blank">qunitjs.com</a> ~</h2>
			<h2>Problem</h2>
			<p> When tests are lumped together, it's possible to have tests that 
			should pass but fail or tests that should fail but pass. This is a 
			result of a test having invalid results because of side effects of
			a previous test.
			
			<br/>
			<textarea class="codeBlock">
QUnit.test( "2 asserts", function( assert ) {
  var $fixture = $( "#qunit-fixture" );
 
  $fixture.append( "<div>hello!</div>" );
  assert.equal( $( "div", $fixture ).length, 1, "div added successfully!" );
 
  $fixture.append( "<span>hello!</span>" );
  assert.equal( $( "span", $fixture ).length, 1, "span added successfully!" );
});
			</textarea>
			<br/><br/>
			The first append() adds a &lt;div&gt; that the second equal() doesn't take into account
			<p>
			<h2>Solution</h2>
			<p>
			Use the <strong>QUnit.test()</strong> method to keep tests atomic, 
			being careful to keep each assertion clean of any possible side effects. 
			You should only rely on the fixture markup, inside the<strong>#qunit-fixture</strong>
			element. Modifying and relying on anything else can have side effects.
			
			<br/>
			<textarea class="codeBlock">
QUnit.test( "Appends a div", function( assert ) {
  var $fixture = $( "#qunit-fixture" );
 
  $fixture.append( "<div>hello!</div>" );
  equal( $( "div", $fixture ).length, 1, "div added successfully!" );
});
 
QUnit.test( "Appends a span", function( assert ) {
  var $fixture = $( "#qunit-fixture" );
 
  $fixture.append("<span>hello!</span>" );
  assert.equal( $( "span", $fixture ).length, 1, "span added successfully!" );
});
			</textarea>
			</p>
			
			<p>QUnit will reset the elements inside the #qunit-fixture element 
			after each test, removing any events that may have existed. As long 
			as you use elements only within this fixture, you don't have to 
			manually clean up after your tests to keep them atomic.
			</p>
			
			<p><strong>Tip: </strong> QUnit also offers a ?noglobals flag. Consider the following test below:
			<br/><br/>
			<textarea class="codeBlock">
QUnit.test( "global pollution", function( assert ) {
  window.pollute = true;
  assert.ok( pollute, "nasty pollution" );
});
			</textarea>
			</p> 
			<p>"In a normal test run, this passes as a valid result. 
			Running the <strong>ok()</strong> test with the noglobals 
			flag will cause the test to fail, because QUnit detected 
			that it polluted the window object.There is no need to use this 
			flag all the time, but it can be handy to detect global namespace 
			pollution that may be problematic in combination with 
			third-party libraries. And it helps to detect bugs 
			in tests caused by side effects."
			</p>
			</div>
			<div id="content-8" class="contentPanels">
			<h1>QUnit-Grouping Tests</h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/" target="blank">qunitjs.com</a> ~</h2>
			<h2>Problem</h2>
			<p>
			"You've split up all of your tests to keep them atomic and free of 
			side effects, but you want to keep them logically organized and be 
			able to run a specific group of tests on their own."
			</p>
			<h2>Solution</h2>
			<p>"You can use the <strong>QUnit.module()</strong> function 
			to group tests together."
			
			<br/>
			<textarea class="codeBlock">
QUnit.module( "group a" );
QUnit.test( "a basic test example", function( assert ) {
  assert.ok( true, "this test is fine" );
});
QUnit.test( "a basic test example 2", function( assert ) {
  assert.ok( true, "this test is fine" );
});
 
QUnit.module( "group b" );
QUnit.test( "a basic test example 3", function( assert ) {
  assert.ok( true, "this test is fine" );
});
QUnit.test( "a basic test example 4", function( assert ) {
  assert.ok( true, "this test is fine" );
});
			</textarea>
			
			<br/><br/>
			"All tests that occur after a call to <strong>QUnit.module() </strong> will be
			grouped into that module. The test names will all be preceded by the 
			module name in the test results."
			</p>
			
			<p>"In addition to grouping tests, <strong>QUnit.module()</strong>
			can be used to extract common code from tests within that module. 
			The <strong>QUnit.module()</strong>function takes an optional 
			second parameter to define functions to run before and after 
			each test within the module."
			
			<br/>
			<textarea class="codeBlock">
QUnit.module( "module", {
  setup: function( assert ) {
    assert.ok( true, "one extra assert per test" );
  }, teardown: function( assert ) {
    assert.ok( true, "and one extra assert after each test" );
  }
});
QUnit.test( "test with setup and teardown", function() {
  expect( 2 );
});
			</textarea>
			<br/> 
			"You can specify both setup and teardown properties together, 
			or just one of them. Calling <strong>QUnit.module()</strong> 
			again without the additional argument will simply reset 
			any setup/teardown functions defined by another module previously."
			</p>
			</div>
			<div id="content-9" class="contentPanels">
			<h1>QUnit-Custom Assertions</h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/" target="blank">qunitjs.com</a> ~</h2>
			<h2>Problem</h2>
			<p>"You have several tests that duplicate logic for asserting some expectation. This repetitive code lessens 
			the readability of your tests and increases the surface for bugs."
			<br/>
			<textarea class="codeBlock">
QUnit.test( "retrieving object keys", function( assert ) {
  var objectKeys = keys( { a: 1, b: 2 } );
  assert.ok( objectKeys.indexOf("a") > -1, "Object keys" );
  assert.ok( objectKeys.indexOf("b") > -1, "Object keys" );
 
  var arrayKeys = keys( [1, 2] );
  assert.ok( arrayKeys.indexOf("1") > -1, "Array keys" );
  assert.ok( arrayKeys.indexOf("2") > -1, "Array keys" );
});
			</textarea>
			</p>
			<h2>Solution</h2>
			<p>"Define a function to encapsulate the expectation in a reusable unit. Invoke 
			<strong>QUnit.push</strong> within the body 
			to notify QUnit that an assertion has taken place."
			<br/>
			<textarea class="codeBlock">
QUnit.assert.contains = function( needle, haystack, message ) {
  var actual = haystack.indexOf(needle) > -1;
  QUnit.push(actual, actual, needle, message);
};
QUnit.test("retrieving object keys", function( assert ) {
  var objectKeys = keys( { a: 1, b: 2 } );
  assert.contains( "a", objectKeys, "Object keys" );
  assert.contains( "b", objectKeys, "Object keys" );
 
  var arrayKeys = keys( [1, 2] );
  assert.contains( "1", arrayKeys, "Array keys" );
  assert.contains( "2", arrayKeys, "Array keys" );
});
			</textarea>
			</p>
			<p>"Custom assertions can help make test suites more readable 
			and more maintainable. At a minimum, they are simply functions 
			that invoke <strong>QUnit.push </strong> with a Boolean 
			value--this is how QUnit detects that an assertion has 
			taken place and the result of that assertion.It is a good 
			practice to define this function as a method on 
			the global <strong>QUnit.assert</strong> object. This helps 
			communicate the purpose of the function to other developers. 
			You may accomplish this by directly assigning a new 
			property on the object (i.e. <strong>QUnit.assert.myAssertion = myAssertion;</strong>)
			or using <strong>QUnit.extend</strong> (i.e. <strong>QUnit.extend(QUnit.assert, { myAssertion: myAssertion });</strong>)".
			
			</p>
			</div>
			<div id="content-10" class="contentPanels">
			<h1>QUnit-Efficient Development</h1>
			<h2>~ JavaScript Unit Testing from <a href="http://qunitjs.com/cookbook/"target="blank">qunitjs.com</a> ~</h2>
			<h2>Problem</h2>
			<p>"Once your testsuite takes longer than a few seconds to run, you want to avoid wasting a lot of time just
			waiting for test results to come in."
			</p>
			<h2>Solution</h2>
			<p>"QUnit has a bunch of features built in to make up for that. 
			The most interesting ones require just a single click to activate. 
			Toggle the "Hide passed tests" checkbox at the top, and QUnit will 
			only show you tests that failed. That alone doesn't make a difference 
			in speed, but already helps focusing on failing tests. It gets more 
			interesting if you take another QUnit feature into account, 
			which is enabled by default and usually not noticable. 
			Whenever a test fails, QUnit stores the name of that test in 
			<strong>sessionStorage</strong>. The next time you run a testsuite, 
			that failing test will run before all other tests. The output 
			order isn't affected, only the execution order. In combination 
			with the "Hide passed tests" checkbox you will then get to see 
			the failing test, if it still fails, at the top, as soon as possible."
			</p>
			<p>"The automatic reordering happens by default. It implies that your 
			tests need to be atomic, as discussed previously. If your tests aren't, 
			you'll see random non-deterministic errors. Fixing that is usually the 
			right approach. If you're really desperate, you can set <strong>QUnit.config.reorder = false</strong>.
			In addition to the automatic reordering, there are a few manual options available. 
			You can rerun any test by clicking the "Rerun" link next to that test. 
			That will add a "testNumber=N" parameter to the query string, where "N" 
			is the number of the test you clicked. You can then reload the page to 
			keep running just that test, or use the browser's back button to go back 
			to running all tests".
			</p>
			<p>"Running all tests within a module works pretty much the same way, 
			except that you choose the module to run using the select at the top 
			right. It'll set a "module=N" query string, where "N" is the encoded 
			name of the module, for example "?module=testEnvironment%20with%20object".
			
			</p>
			</div>

			</div>
        </div>
    </body>
</html>